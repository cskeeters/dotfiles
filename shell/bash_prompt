#!/bin/bash

prompt_color="\001\e[%sm\002%s\001\e[0m\002"

function parse_hg_branch() {
    local dirty=0 newfile=0 deleted=0 untracked=0 indicators=""

    BRANCH=$(hg branch 2> /dev/null)
    if [[ $BRANCH != "" ]]; then
        # hg par is fast, id is slow over nfs
        REV=$(hg par --template '{rev},')
        [[ $REV =~ ([[:digit:]]+),([[:digit:]]+), ]] && REV=${BASH_REMATCH[1]},${BASH_REMATCH[2]}
        [[ $REV =~ ([[:digit:]]+),$ ]] && REV=${BASH_REMATCH[1]}

        BRCOLOR=37 # White means no status checked
        REVCOLOR=37 # White means no status checked

        # If the current directory is on an nfs mount, don't run hg sta, or hg id, too slow
        if [[ ! $(df -PT . | sed -n 2p | awk '{ print $2 }') =~ nfs ]]; then
            BRCOLOR=35 # purple == Clean
            REVCOLOR=35 # purple == Clean
            if [[ $REV != -1 ]]; then
                # If no commits id -n returns -1, but this outputs an error
                BREV=$(hg identify -nr $(hg identify -b) 2> /dev/null)
            fi
            # Red, not on latest revision for branch
            [[ $REV == $BREV ]] || BRCOLOR=31

            parse_hg_status
            # set_indicators_hg_single
            (($untracked)) && REVCOLOR=33 # Yellow == Dirty
            (($dirty)) || (($newfile)) || (($deleted)) && REVCOLOR=31 # Red == Dirty
        fi

        printf $prompt_color $BRCOLOR "${BRANCH}"
        printf ":"
        printf $prompt_color $REVCOLOR "${REV}${indicators} "
    fi
}

# get current status of hg repo
function parse_hg_status {
    # local dirty=1 newfile=1 deleted=1 untracked=1
    while IFS= read -r -d $'\n' line; do
        [[ $line =~ ^M ]] && dirty=1
        [[ $line =~ ^A ]] && newfile=1
        [[ $line =~ ^R ]] && deleted=1
        [[ $line =~ ^\? ]] && untracked=1
    done < <(hg status 2>&1)

}

function set_indicators_hg_single() {
    indicators=''
    ((${untracked})) && indicators="?"
    (($dirty)) || (($newfile)) || (($deleted)) && indicators="+"
    echo $indicators
}

function set_indicators_hg_multi() {
    indicators=''
    (($newfile)) && indicators="+${indicators}"
    (($untracked)) && indicators="?${indicators}"
    (($deleted)) && indicators="x${indicators}"
    (($dirty)) && indicators="!${indicators}"
}

# get current branch in git repo
function parse_git_branch() {
    local dirty=0 untracked=0 ahead=0 newfile=0 renamed=0 deleted=0 indicators=""
    BRANCH=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
    if [ ! "${BRANCH}" == "" ]; then
        parse_git_status
        set_indicators_git_multi

        dirty_color=34
        [[ $indicators != "" ]] && dirty_color=33

        printf $prompt_color 35 "${BRANCH}"
        printf $prompt_color 31 "${indicators} "
        # printf $prompt_color $dirty_color " Â± "
        # printf $prompt_color $dirty_color " + "
    fi
}


# get current status of git repo
function parse_git_status {
    while IFS= read -r -d $'\n' line; do
        [[ $line =~ modified: ]] && dirty=1
        [[ $line =~ Untracked\ files ]] && untracked=1
        [[ $line =~ Your\ branch\ is\ ahead\ of ]] && ahead=1
        [[ $line =~ new\ file: ]] && newfile=1
        [[ $line =~ renamed: ]] && renamed=1
        [[ $line =~ deleted: ]] && deleted=1
    done < <(git status 2>&1)

}

function set_indicators_git_multi() {
    indicators=''
    ((${renamed})) && indicators=">${indicators}"
    ((${ahead})) && indicators="*${indicators}"
    ((${newfile})) && indicators="+${indicators}"
    ((${untracked})) && indicators="?${indicators}"
    ((${deleted})) && indicators="x${indicators}"
    ((${dirty})) && indicators="+${indicators}"
}

function nonzero_return() {
    RETVAL=$?
    [[ $RETVAL -ne 0 ]] && printf $prompt_color 31 "$RETVAL "
}

export PS1="\`nonzero_return\`\[\e[35m\]\u\[\e[0m\]@\[\e[33m\]\h\[\e[0m\] \[\e[36m\]\w\[\e[0m\] \`parse_git_branch\`\`parse_hg_branch\`"
